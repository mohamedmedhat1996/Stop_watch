#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>

#define NUMBER_OF_OVERFLOWS_PER_HALF_SECOND 2
#define second 4
#define min 240
#define hour 14400

unsigned char Flag_0 = 0;
unsigned char Flag_1 = 0;
unsigned char Flag_2 = 0;
unsigned char num = 0;
unsigned char g_tick_sec = 0;
unsigned char g_tick_min = 0;
unsigned char g_tick_hr = 0;
unsigned char pause = 0;
int sec=0;
unsigned char sec1 = 0;
unsigned char sec2 = 0;
/*Initialization GPIO*/
void GPIO_INIT(void)
{



/*PORT A*/
DDRA|=(1<<PA0)|(1<<PA1)|(1<<PA2)|(1<<PA3)|(1<<PA4)|(1<<PA5);

PORTA|=(1<<PA0)|(1<<PA1)|(1<<PA2)|(1<<PA3)|(1<<PA4)|(1<<PA5);

/*PORT C*/
DDRC |= 0x0F;
PORTC &= 0xF0;
}

/* ISR */
ISR(INT0_vect)
{
	Flag_0 = 1;
}
ISR(INT1_vect)
{
	pause=1;

}
ISR(INT2_vect)
{


	num = 0;
	PORTC = (PORTC & 0xF0) | (num & 0x0F);
	_delay_ms(500);
}
ISR(TIMER0_COMP_vect)
{
	g_tick_sec++;
	g_tick_min++;
	g_tick_hr++;

	if(g_tick_sec == second)
	{
		num++;
		PORTC=0;
		PORTA=(1<<PA1)|(1<<PA2)|(1<<PA3)|(1<<PA4)|(1<<PA5);
		PORTA&=~(1<<PA1);
		PORTA&=~(1<<PA2);
		PORTA&=~(1<<PA3);
		PORTA&=~(1<<PA4);
		PORTA&=~(1<<PA5);
		PORTC = 5;
		PORTA=(1<<PA0);
		PORTA&=~(1<<PA0);
		g_tick_sec=0;
	}
/*	if(g_tick_min == min)
		{
			num++;
		   PORTC = (PORTC & 0xF0) | (num & 0x0F);

			g_tick_min=0;
		}
	if(g_tick_hr == hour)
			{
				num++;
			   PORTC = (PORTC & 0xF0) | (num & 0x0F);

				g_tick_hr=0;
			}
*/
}

/* External INT0 enable and configuration function */
void INT0_Init(void)
{
	SREG  &= ~(1<<7);                   // Disable interrupts by clearing I-bit
	GICR  |= (1<<INT0);                 // Enable external interrupt pin INT0
	MCUCR &= ~ (1<<ISC00);
	MCUCR |= (1<<ISC01);                 // Trigger INT0 with the falling edge
	SREG  |= (1<<7);                    // Enable interrupts by setting I-bit
	/*PORT D*/
	DDRD &=~(1<<PD2);/*PULL UP*/
	PORTD |= (1<<PD2);

}
void INT1_Init(void)
{
	SREG  &= ~(1<<7);      // Disable interrupts by clearing I-bit
	GICR  |= (1<<INT1);    // Enable external interrupt pin INT1
	// Trigger INT1 with the falling edge
	MCUCR |= (1<<ISC11);
	MCUCR &= ~(1<<ISC10);
	SREG  |= (1<<7);       // Enable interrupts by setting I-bit
	DDRD &=~(1<<PD3);/*PULL DOWN*/
}
void INT2_Init(void)
{
	SREG  &= ~(1<<7);
	DDRB &=~(1<<PB2); /*PULL UP*/
	PORTB |= (1<<PB2);// Disable interrupts by clearing I-bit
	GICR  |= (1<<INT2);    // Enable external interrupt pin INT1
	MCUCSR &= ~ (1<<ISC2);
	SREG  |= (1<<7);       // Enable interrupts by setting I-bit


}
void timer0_init_CTC_mode(unsigned char tick)
{
	TCNT0 = 0;
	OCR0  = tick;
	TIMSK |= (1<<OCIE0);
	TCCR0 = (1<<FOC0) | (1<<WGM01) | (1<<CS02) | (1<<CS00);
}

int main(void)
{

	GPIO_INIT();
	INT0_Init();
	INT1_Init();
	INT2_Init();
	timer0_init_CTC_mode(250);

	PORTC = (PORTC & 0xF0) | (num & 0x0F);
	_delay_ms(500);
	while(1)
	{
		if(Flag_0==1)
		{
			num = 0;
			PORTC = (PORTC & 0xF0) | (num & 0x0F);
		   _delay_ms(500);
		   Flag_0=0;
		}

		else
		{
            while(1)
		{
		/*
            num++;
            PORTC=0;
            PORTA=(1<<PA1)|(1<<PA2)|(1<<PA3)|(1<<PA4)|(1<<PA5);
			PORTA&=~(1<<PA1);
			PORTA&=~(1<<PA2);
			PORTA&=~(1<<PA3);
			PORTA&=~(1<<PA4);
			PORTA&=~(1<<PA5);
			PORTC = 5;
			PORTA=(1<<PA0);
			PORTA&=~(1<<PA0);
			sec1=0;
		*/


		}


		}


	}
}

