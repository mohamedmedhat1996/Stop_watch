#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>

#define NUMBER_OF_OVERFLOWS_PER_HALF_SECOND 2

unsigned char Flag_0 = 0;
unsigned char Flag_1 = 0;
unsigned char Flag_2 = 0;
unsigned char num = 0;
unsigned char g_tick = 0;
int sec=0;
/*Initialization GPIO*/
void GPIO_INIT(void)
{



/*PORT A*/
DDRA|=(1<<PA0)|(1<<PA1)|(1<<PA2)|(1<<PA3)|(1<<PA4)|(1<<PA5);
PORTA|=(1<<PA0)|(1<<PA1)|(1<<PA2)|(1<<PA3)|(1<<PA4)|(1<<PA5);
/*PORT C*/
DDRC |= 0x0F;
PORTC &= 0xF0;
}

/* ISR */
ISR(INT0_vect)
{
	Flag_0 = 1;
}
ISR(INT1_vect)
{
	PORTC  = 5;

}
ISR(INT2_vect)
{


	num = 0;
	PORTC = (PORTC & 0xF0) | (num & 0x0F);
	_delay_ms(500);
}
ISR(TIMER0_COMP_vect)
{
	g_tick++;
	if(g_tick == NUMBER_OF_OVERFLOWS_PER_HALF_SECOND)
	{
		sec=1;
	}
}

/* External INT0 enable and configuration function */
void INT0_Init(void)
{
	SREG  &= ~(1<<7);                   // Disable interrupts by clearing I-bit
	GICR  |= (1<<INT0);                 // Enable external interrupt pin INT0
	MCUCR &= ~ (1<<ISC00);
	MCUCR |= (1<<ISC01);                 // Trigger INT0 with the falling edge
	SREG  |= (1<<7);                    // Enable interrupts by setting I-bit
	/*PORT D*/
	DDRD &=~(1<<PD2);/*PULL UP*/
	PORTD |= (1<<PD2);

}
void INT1_Init(void)
{
	SREG  &= ~(1<<7);      // Disable interrupts by clearing I-bit
	GICR  |= (1<<INT1);    // Enable external interrupt pin INT1
	// Trigger INT1 with the falling edge
	MCUCR |= (1<<ISC11);
	MCUCR &= ~(1<<ISC10);
	SREG  |= (1<<7);       // Enable interrupts by setting I-bit
	DDRD &=~(1<<PD3);/*PULL DOWN*/
}
void INT2_Init(void)
{
	SREG  &= ~(1<<7);
	DDRB &=~(1<<PB2); /*PULL UP*/
	PORTB |= (1<<PB2);// Disable interrupts by clearing I-bit
	GICR  |= (1<<INT2);    // Enable external interrupt pin INT1
	MCUCSR &= ~ (1<<ISC2);
	SREG  |= (1<<7);       // Enable interrupts by setting I-bit


}
void timer0_init_CTC_mode(unsigned char tick)
{
	TCNT0 = 0;
	OCR0  = tick;
	TIMSK |= (1<<OCIE0);
	TCCR0 = (1<<FOC0) | (1<<WGM01) | (1<<CS02) | (1<<CS00);
}

int main(void)
{

	GPIO_INIT();
	INT0_Init();
	INT1_Init();
	INT2_Init();
	timer0_init_CTC_mode(250);
	PORTC = (PORTC & 0xF0) | (num & 0x0F);
	_delay_ms(500);
	while(1)
	{
if(sec==1)
{
		//PORTA &=~(1<<PA0);
		if(Flag_0==1)
		{
			num = 0;
			PORTC = (PORTC & 0xF0) | (num & 0x0F);
		   _delay_ms(500);
		   Flag_0=0;
		}

		else
		{


			// increment 7-segment every press

			if((PORTC & 0x0F) == 9)
			{
				num = 0;
				PORTC = (PORTC & 0xF0) | (num & 0x0F);
				//_delay_ms(500);
			}
			else
			{


				num++;
				PORTC = (PORTC & 0xF0) | (num & 0x0F);


				//_delay_ms(500);


				//PORTA|=(1<<PA0)|(1<<PA1)|(1<<PA2)|(1<<PA3)|(1<<PA4)|(1<<PA5);

			}

		}
}
//sec=0;
	}
}

